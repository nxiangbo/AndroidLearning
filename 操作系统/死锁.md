# 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

## 

## 产生死锁的必要条件

 - **互斥**：mutual exclusion

即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。

 - **禁止抢占**：no preemption

进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

 - **持有和等待**：hold and wait

进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

 - **循环等待**：circular waiting

存在一个进程等待序列${P_1，P_2，...，P_n}$，其中P1等待P2所占有的某一资源，$P_2$等待$P_3$所占有的某一源，......，而$P_n$等待$P_1​$所占有的的某一资源，形成一个进程循环等待环。

<br>
## 死锁的预防

上述四个条件是产生死锁的必要条件，缺一不可.只要破坏死锁的四个必要条件中的任意一个就可以预防死锁发生。

 - **破坏互斥条件**：即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。
     <br>
 - **破坏不可抢占条件**：即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。    
     <br>
 - **破坏持有和等待条件**：可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。
    <br>
 - **破坏循环等待条件**：实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。

## 死锁的避免

上面讲述的死锁预防的方法是防止死锁的静态策略，它使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动进行限制，以保证死锁不会发生。下面我们介绍排除死锁的**动态策略**-**-死锁的避免**，它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。
### 银行家算法

在介绍银行家算法之前，我们首先引入**安全序列**的定义：所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列${P_1，P_2，...，P_n}​$就是安全序列。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。

银行家算法的**基本思想**是分配资源之前，判断系统是否是安全的；若是，才分配。

### 例子

Allocation　　　Max　　　Available
 　　ＡＢＣＤ　　ＡＢＣＤ　　ＡＢＣＤ
 P1　００１４　　０６５６　　１５２０　
 P2　１４３２　　１９４２　
 P3　１３５４　　１３５６
 P4　１０００　　１７５０

 


### 算法代码

P - 进程的集合
Mp - 进程p的最大的请求数目
Cp - 进程p当前被分配的资源
A - 当前可用的资源

```c
while (P != ∅) {
    found = FALSE;
    foreach (p ∈ P) {
        if (Mp − Cp ≤ A) {
             /* p可以获得他所需的资源。假设他得到资源后执行；执行终止，并释放所拥有的资源。*/
             A = A + Cp ;
             P = P − {p};
             found = TRUE;
        }
    }
    if (! found) return FAIL;
}
return OK;
```

## 死锁的检测和恢复

### 死锁的恢复

一旦在死锁检测时发现了死锁，就要消除死锁，使系统从死锁状态中恢复过来。

（1）最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。
<br>
（2）撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素。 

 

## 用Java写一个死锁例子

定义两个ArrayList,将他们都加上锁A,B，线程1,2，1拿住了锁A ，请求锁B，2拿住了锁B请求锁A，在等待对方释放锁的过程中谁也不让出已获得的锁。

```java
public class DeadLock {
    public static void main(String[] args) {
        final List<Integer> list1 = Arrays.asList(1, 2, 3);
        final List<Integer> list2 = Arrays.asList(4, 5, 6);
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (list1) {
                    for (Integer i : list1) {
                        System.out.println(i);
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (list2) {
                        for (Integer i : list2) {
                            System.out.println(i);
                        }
                    }
                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (list2) {
                    for (Integer i : list2) {
                        System.out.println(i);
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (list1) {
                        for (Integer i : list1) {
                            System.out.println(i);
                        }
                    }
                }
            }
        }).start();

    }
}
```