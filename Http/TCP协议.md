# TCP协议
TCP的主要特点：

- TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接。在传送完数据后，必须释放已经建立的TCP连接。

- 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接必须是点对点的。
- TCP提供可靠的交付的服务。也就是说，通过TCP传输的数据，无差错、不丢失、不重复、并且按时到达。
- TCP提供全双工的通信。TCP允许通信的双方的应用进程在任何人时候都能发送数据。

- 面向字节流。TCP中的“流”指的是流入到进程或者从进程流出的字节序列。

## TCP的连接

TCP把连接作为最基本的抽象。每一条TCP连接都有两个端点。TCP中的端点叫做套接字（socket）或插口。
套接字 socket = （IP地址：端口号）
每一条ＴＣＰ连接唯一的被通信两端的两个端点（即两个套接字）所确定。即ＴＣＰ连接 :={socket1，socket2} = {（IP1：port1），（IP2：port2）}

### TCP报文段的首部格式
![](https://leanote.com/api/file/getImage?fileId=57ad2a7bab644133ed049130)
TCP报文段的首部的前20个字节是固定的。

- 源端口和目的端口。各占两个字节，分别写入源端口号和目的端口号。

- 序号。4个字节，序号使用mod 2^32计算。首部中的序号字段值则指的是本报文段所发送的第一个字节的序号。

- 确认号。4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号 = N,则表明：到序号N-1为止的所有数据都已正确收到。

- 数据偏移。4个字节。它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。

- 保留

- 紧急URG（URgent）。当URG=1时，表明紧急指针字段有效。它告诉系统此报文应该尽快传送（相当于高优先级的数据）。与紧急指针配合使用。

- 确认ACK（ACKnowlegment）。仅当ACK=1时确认号才有效。当ACK=0时，确认号无效。TCP规定，在建立连接后所有传送的报文段都必须把ACK设置为1。

- 推送PSH（PuSH）。当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，此时，可以将PSH设置为1.

- 复位ＲＳＴ（ReSeT）。当RST=1时，表明TCP连接出现严重的差错，必须释放连接，然后再重新建立连接进行传输。

- 同步SYN（SYNchronization）。在建立连接时进行同步序号。当SYN=1且ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则在响应的报文段中使SYN=1和ACK=1.

- 终止FIN（FINis）。用来释放一个连接。当FIN=1时，表明此报文段的发送方数据已发送完毕，并要求释放连接。

- 窗口。窗口指的是发送本报文段的一方的接收窗口（不是自己的发送窗口）。窗口字段明确指出现在允许对方发送的数据量。窗口值是动态变化的。

- 校验和 占2个字节。检验和字段检验的范围包括首部和数据这部分。

- 紧急指针 2个字节。紧急指针仅在URG=1时才有意义。

- 选项  长度可变。

## TCP的运输连接管理

TCP是面向连接的协议。运输链接是用来传送TCP报文的。TCP运输连接的简历和释放是面向连接的通信中不可少的过程。因此，运输连接有三个阶段：连接阶段、数据传送和连接释放。运输连接的管理就是使得运输连接的建立和释放都能正常的进行。
TCP的连接采用客户服务器方式。主动发起连接的引用进程叫做客户。而被动等待连接建立的应用进程叫做服务器。

### TCP的连接建立--三次握手协议
![](https://leanote.com/api/file/getImage?fileId=57ad2a7bab644133ed04912f)
B的TCP服务进程先创建传输控制块TCB（TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号等信息），准备接收客户端连接的请求，然后服务器进程就处于LISTEN状态。

- A的TCP客户进程首先创建传输控制块TCB，然后向B发出连接请求报文段，这时首部中的SYN=1，同时选择一个初始序号seq=x。SYN报文段不携带数据，但要消耗一个序号。TCP客户进程处于同步已发送状态（SYN_SENT）。
- B收到连接请求报文后，如果同意建立连接，则向A发送确认。在确认报文段中SYN=1，ACK=1，确认号是ack=x+1，同时自己的初始序号为seq=y。注意，这个报文端也不能携带数据，但同样要消耗掉一个序号。此时，TCP服务器进程进入SYN-RCVD（同步收到）状态。
- TCP客户进程收到B的确认后，还要向B给出确认。确认报文段中ACK=1，确认号ack=y+1，而自己的序号为seq=x+1.TCP标准规定，ACK报文段可以携带数据。但如果不携带数据，则不消耗序号。此时，TCP连接已经建立，A进入已建立连接状态。当B收到A的确认后，也进入已建立连接状态。

为什么A还要向B发送一次确认呢？
这主要是为了防止已失效的连接请求报文段突然又传送到B，因而产生错误。

### TCP连接的释放--四次挥手协议

数据传输完成后，通信双方都可以释放连接。
![](https://leanote.com/api/file/getImage?fileId=57ad2a7bab644133ed04912e)

- A的应用进程先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部FIN=1，其序号seq=u（u等于前面已传送过的最后一个字节的序号加1）。此时，A进入FIN-WAIT-1(终止等待)状态，等待B确认。注意，FIN报文段即时不携带数据，也要消耗一个序号。
- B收到连接释放报文段后即发出确认，确认号ack=u+1，而这个报文段的序号seq=v。然后，B就进入CLOS-WAIT（关闭等待）状态。TCP服务进程应该通知高层应用进程，因此，从A到B这个方向的连接关闭，此时，TCP连接处于半关闭（half-close）状态。对于A，收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。

- 若B已经不需要向A发送数据，其应用进程就通知TCP释放连接。此时，B发出的连接释放报文段FIN=1，序号seq=w，确认号ack=u+1.这时B就进入LAST-ACK（最后确认）状态，等待A的确认。
- A在收到B的连接释放报文后，必须对此确认。确认报文段ACK=1，确认号ack=w+1,自己的序号seq= u+1.然后进入到TIME-WAIT（时间等待）状态。注意，此时TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置时间2MSL后，A才进入CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。

为什么A在TIME-WAIT状态必须等待2MSL时间呢？
原因1，为了保证A发送的最后一个ACK报文段能够到达B。若ACK报文段丢失，还有超时重传的时间。
原因2，防止上面提到的“已失效的连接请求报文段”出现在本链接中。

B只要收到A发出的确认，就进入CLOSED状态。此时，TCP连接释放。 

