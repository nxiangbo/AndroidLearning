# 线程安全性
## 什么是线程安全性
当多个线程访问某个类时，不管运行时采用何种调度方式或者这些线程如何交替的执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么称这个类是线程安全的。

在线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。

无状态对象一定是线程安全的.

## 原子性

### 竞态条件
当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。在并发编程中，由于不恰当的执行顺序而出现不正确的结果，这就是竞态条件。

### 复合操作

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个以原子方式执行的操作。
在`java.util.concurrent.atomic`包中包含一些原子变量类，如`AtomicLong`等。通过使用`AtomicLong`代替`Long`类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。

## 加锁机制

要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

### 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块( synchronized block)。同步代码块包括两部分：
- 作为锁的对象的引用。以关键字synchronized修饰的方法就是一个横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。

- 作为由这个锁保护的代码块。静态的synchronized方法以Class对象作为锁。

### 重入
如果某个线程尝试获得一个已经由他持有的锁，那么这个请求是成功的，也就是可重入的。重入的实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就没有被任何线程持有。当线程请求一个空闲的锁时，获取计数值会置为1。如果同一个线程再次获得这个锁，计数值将递增，而线程退出同步代码块时，将递减。当计数值为0时，将会释放这个锁。

